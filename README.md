
## | Дипломный проект по курсу python-Разработчик на тему: "Telegram-бот для определения изображений с помощью предобученной модели машинного обучения"


## ▎Структура проекта

- **Регистрация пользователей**: Бот регистрирует пользователей по их уникальному ID.
- **Обработка изображений**: Распознавание объектов на изображениях, отправленных пользователем.
- **Контроль лимита**: Система ограничений на количество операций обработки изображений в день.
- **Обработка оплаты подписки для увеличения лимита**: Используются возможности API Telegram.

---

## ▎Используемые библиотеки

- `aiogram` — для взаимодействия с Telegram API.
- `aiohttp` — для выполнения асинхронных HTTP-запросов.
- `certifi` — для работы с SSL-сертификатами.
- `asyncio` — обработка изображений.
- `torch` — для работы с машинным обучением.
- `torchvision` — для реализации компьютерного зрения и работы с изображениями.
- `Pillow` — для загрузки, обработки и сохранения изображений.
---

## ▎Функциональность

### ▎Файл bot.py

Бот интегрирован с кастомными клавиатурами и поддерживает управление платежами, предоставляя удобный интерфейс для пользователей. Код построен с упором на модульность, простоту добавления новых функций и обработчиков.
При отправке команды "Зарегистрироваться", бот проверяет, зарегистрирован ли пользователь. 
Если пользователь не зарегистрирован, то добавляет его в базу данных.
Основная функция модуля инициализировать запуск бота через `TOKEN` Telagram.
И реализовать панель управления для пользователя.
Кнопка регистрации пользователя:
```
@router.message(F.text == "Зарегистрироваться")
async def cmdregister(message: Message):
    userid = message.fromuser.id
    isregistered = registeruser(userid)

    if isregistered:
        await message.answer("✅ Вы успешно зарегистрированы!")
    else:
        await message.answer("❌ Вы уже зарегистрированы.")
```
![Регистрация пользователя](/imagesreadme/1.png)
---
### ▎Файл handlers.py
Файл `handlers.py` отвечает за обработку текстовых команд и изображений, отправленных пользователями, с применением библиотеки aiogram. 
Его основные функции включают:

1. Регистрация пользователей:
   - Обработка команды "Зарегистрироваться".
   - Проверка регистрационного статуса пользователя.
   - Информирование о успехе или об ошибке повторной регистрации.

2. Обработка изображений:
- Проверка лимита на использование (при подписке или без неё).
- Загрузка изображений из Telegram.
- Сохранение изображения локально.
- Обработка изображения с использованием функции process_image().
- Отправка результатов распознавания пользователю.

3. Обработка ошибок:
- Пользователь получает сообщение об ошибке в случае, если:
- В процессе работы возникает проблема с загрузкой/обработкой фото.
- Лимит на использование превышен.


### Обработка фотографий

Пользователь может отправить фото, которое будет скачано и обработано. 
Если лимит обработки превышен, бот уведомляет об этом.
Реализовано подключение по HTTPresponse с Тelеgram для перадачи изображения с расшинеринем JPG для последующей обработки.


```
@router.message(F.photo)
async def handlephoto(message: Message, bot: Bot):
    userid = message.fromuser.id

    # Проверка лимита
    if not checklimit(userid):
        await message.answer(
            "❌ Вы исчерпали свой дневной лимит на обработку изображений. "
            "Оформите подписку для доступа без ограничений.")
        return

    try:
        # Получение и сохранение фото локально
        photo = message.photo-1
        fileid = photo.fileid
        fileinfo = await bot.getfile(fileid)
        filepath = fileinfo.filepath
        localfilepath = f"images/{photo.fileuniqueid}.jpg"
        fullurl = f"https://api.telegram.org/file/bot<токен>/{filepath}"
        sslcontext = ssl.createdefaultcontext(cafile=certifi.where())

        # Асинхронное скачивание фото
        async with aiohttp.ClientSession() as session:
            async with session.get(fullurl, ssl=sslcontext) as response:
                if response.status == 200:
                    with open(localfilepath, "wb") as f:
                        f.write(await response.read())
                else:
                    raise Exception(f"Ошибка при скачивании файла, статус: {response.status}")

        # Обработка изображения
        result = processimage(localfilepath)
        if result:
            await message.answer(f"На изображении распознан объект: {result}")
        else:
            await message.answer("❌ Объект на изображении не распознан.")
    except Exception as e:
        await message.answer("❌ Произошла ошибка при обработке изображения.")
        print(f"Ошибка обработки изображения: {e}")
```
---
![Блокировка обработки изображений без приобретенной подписки](/imagesreadme/3.png)
---
### ▎Файл image_model.py
В данном файле выполняется загрузка предобученной модели `ResNet`
Используется `imagenet_classes.txt` описание объектов определения.
Благодаря модульности и поддержке готовой модели `ResNet` возмжоно реализовать 
определение нескольких объектов на одном изображении и даже при неоднозначных признаках.

Применение модели машинного обучения `ResNet` с конвертацией RGB чтобы он был пригоден для подачи в нейронную сеть, если изначально был в другом формате.
Обеспечивается выполние:
— transform(image): предварительной обработки изображения. Также предусмотрено сжатие изображения до определенного размера, нормализацию значений пикселей и преобразование в тензор (torch.Tensor).
— unsqueeze(0): дополнительноого измерение к тензору — это необходимо, чтобы изображение воспринималось моделью.

```
def process_image(image_path: str) -> str:
    """
    Обрабатывает изображение и возвращает название распознанного объекта.
    """
    try:
        # Открытие и обработка изображения
        image = Image.open(image_path).convert("RGB")
        input_tensor = transform(image).unsqueeze(0)

        # Предсказания модели
        with torch.no_grad():
            outputs = model(input_tensor)

        _, predicted_idx = outputs.max(1)

        return imagenet_classes[predicted_idx.item()]
    except FileNotFoundError:
        return "Ошибка: Файл изображения не найден."
    except Exception as e:
        return f"Ошибка обработки изображения: {e}"
```

![Демонстрация определения объектов](/imagesreadme/2.png)
---
### ▎ Файл payments_methods.py
В данном модуле подключение к платежным системам и и выполняется сравнение лимитов подписки.

```
async def send_invoice(message: Message, subscription_type: str):
    """
    Отправляет счет на оплату указанной подписки.
    """
    user_id = message.from_user.id

    # Проверка решистрации пользователя
    if not await check_user_registered(user_id):
        await message.answer("Вы не зарегистрированы. Пожалуйста, зарегистрируйтесь.")
        return

    if subscription_type in PRICES:
        try:
            # Отправка счета для оплаты
            await message.answer_invoice(


                title=f"Подписка {subscription_type}",
                description=f"Оплата подписки: {subscription_type}.",
                payload=subscription_type,
                provider_token="1744374395:TEST:e0484a35ca500d8ace7e",
                currency="RUB",
                prices=PRICES[subscription_type],
                start_parameter="subscription-payment",
            )
        except Exception as e:
            await message.answer(f"Ошибка отправки счета: {e}")
    else:
        await message.answer("Ошибка: Такой подписки не существует.")
```
![Возможность подключения платной подписки](/imagesreadme/4.png)
![Возможность подключения платной подписки](/imagesreadme/5.png)
![Возможность подключения платной подписки](/imagesreadme/6.png)
![Возможность подключения платной подписки](/imagesreadme/7.png)
![Запись нового лимита для определения изображений](/imagesreadme/8.png)
---
### ▎Файл data_manager.py
Выполняется создание `JSON` которая иммитирут базу данных ведется идентификация пользователей.
Обновляется `JSON` в части любых изменений касающихся данных о пользователе.
В дальнейшем для развития проекта можно подключит SQLite для повышения безопасонсти обраюотки и исключения потерь в `JSON`
В данной функции выполняется сравнение с лимитами определения изображений с привязкой к платным подпискам.
```
def update_subscription(user_id, subscription_type):
    """
    Обновляет подписку пользователя в базе данных.
    """
    data = load_data()

    if str(user_id) not in data:
        return False  # Пользователь не зарегистрирован

    data[str(user_id)]["subscription"] = subscription_type
    data[str(user_id)]["update_date"] = str(datetime.now())  # Дата обновления подписки

    # Устанавливаю лимит для разных подписок
    if subscription_type == "econom":
        data[str(user_id)]["daily_limit"] = 10
    elif subscription_type == "premium":
        data[str(user_id)]["daily_limit"] = 20
    elif subscription_type == "lux":
        data[str(user_id)]["daily_limit"] = float("inf")  # Неограниченные распознавания
    else:
        return False

    save_data(data)
    return True
```
Выполняется перезапись `JSON` после проведения оплаты пользователем и добавлении лимитов определния изображений к user_id.
```
def update_user_subscription(user_id: int, subscription_type: str) -> bool:
    """
    Обновляет данные пользователя после успешной оплаты подписки.
    """
    try:
        with open("init_data.json", "r+") as f:
            data = json.load(f)
            if str(user_id) in data:
                data[str(user_id)]["active_subscription"] = subscription_type
                f.seek(0)
                json.dump(data, f, indent=4)
                f.truncate()
                return True
        return False
    except Exception as e:
        print(f"Ошибка обновления подписки: {e}")
        return False
```
---
### ▎Заключение 
В данной программе продемонстрирована работа телеграмм бота для определния изображений с помощью модели машинного обучения с возможностью подключения плантых услуг.
Программа построена по принципу модульной архитектуры, где каждый функциональный блок отвечает за определенную роль. 
Что позволяет обеспечить высокую гибкость программы, читаемость и функциональность. В рамках работы изучил работу
библиотек выполняющие функции HTTPresponse запросов, работу программ асинхронности с помощью aiogram, 
приобрел навыки работы с системой обработки изображений `torchvision`, `Pillow`. 
Выполнил интеграцию чат-бота при помощи API Telegram.
Данный проект имеет модернизационный потенциал в части подключения базы данных для повышения безопасности 
и исключения ошибок при работе с JSON. Расширение функционала чат-бота на базе определения изображений 
(например: обрабатывать несколько объектов на снимке). Добавить в панель управления больше команд для удобства пользователей.
Таким образом выполненный проект является MVP который позволит наращивать функционал под требования рынка и обеспечивать
развитие функционала данной программы.